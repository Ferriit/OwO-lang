# OwO-Lang Specification

OwO-Lang is build on a set of core ideas:
1. **Pattern-finding over keywords:** the language is parsed and compiled primarily through structure and symbol patterns rather than reserved words
2. **Compact expressiveness:** syntax should communicate maximum meaning with minimal visual noise
3. **Non-clutterness:** symbols shouldn't be attached to a keyword or name to signify something else

This can then be expanded to:

1. All types are fundamentally 16, 32 or 64-bit ints, there's no type-checking 
2. It builds on pattern-finding (if (x == 2) {} becomes x == 2 -> {}) 
3. Function calls don't require parenthesis (printf("Hello, World!") becomes printf "Hello, World!". But int x = y + f(z) becomes x := y + f(z) since the parenthesis are needed for clarity) 
4. The language is fully-procedural like C 
5. It compiles to an intermediary language before that gets compiled to assembly and gets assembled and linked or compiled to the OwOVM.
6. Variable definition doesn't need a special keyword since every variable is an int (except for strings and arrays, both of which are pointers). You just use := instead of = 
7. Functions are defined without a keyword (int main(int argc, char** argv) {} becomes main argc argv {})
8. Assigning pointers shouldn't be with "\*x", it should use a keyword such as "mem" instead of "\*". (&x becomes ref x)

## Compile flags
### Target flags:
- (No target flag) - Transpiles to C with 64-bit everything before calling GCC, Clang, MSVC or whichever C-compiler you have installed
- -compat - Transpiles to C with **32-bit** integers instead of 64 bit. This is to improve backwards **compatibility**
- -vm - Compiles to bytecode that can be read by the OwOVM Virtual Machine
- -fmbyas - Compiles to the FMBYAS instruction set. Turns on **16-bit** integers due to architecture limitations. Can be run either with the [EzCPU](https://github.com/Ferriit/EzCPU/tree/dev) emulator or the EzCPU in the game Scrap Mechanic. Though that requires manually inputting the machine code generated by the [EzCPU](https://github.com/Ferriit/EzCPU/tree/dev) assembler.

### Linking flags:
- -l[library name] - Links whatever library has that library name. Links binaries. Looks in your PATH variable for binaries
- -L[path to library] - Links whatever library binary is at that position
- -ol - Links an OwOVM library file (\*.owol). Looks in your PATH variable
- -oL - Links an OwOVM library file (\*.owol) by its path
- -static - Links statically. Works for both binaries and OwOVM
- -shared - Links dynamically (default). Works for both binaries and OwOVM
*(Note that FMBYAS doesn't support shared/dynamic linking)*


## Keywords:
1. mem - "Memory location of ...". Assigns new memory for a constant and returns a pointer to said constant. If used on a variable (`mem x`), it's the same as `\*x` in C (pointer)
2. ref - "Value at the memory location ...". The same as a dereferencing a pointer (`&x`). **Always preceeds mem**
3. ret - Returns the following value from a function
4. loop - An infinite loop that loops between the following squiggly brackets. (`loop {}` is the same as `while (true) {}`)
5. brk - Breaks out of a loop. The same as `break` in most languages
6. jump - The same as `goto`. Jumps to a specified label
8. imp - Import an OwOVM library or another OwO script either by its path or by looking in PATH. It's indicated the same way as in C with <> and ""


## Variables:

- All variables that can be expressed with a single value are of type int at their core (64-bit on standard, 32-bit if `-compat` is on and 16-bit if `-fmbyas` is on)
- Variables like strings or arrays are expressed as pointers pointing to a memory location

### Variable types:
#### Single-value:
- All such variables are integers except floats.
1. ints behave like normal
1. bools are false if they're exactly equal to 0b0 and true otherwise
1. chars works as in C with each character being mapped to a certain int

- Floats are assigned as "float" and not "int" (meaning you can't do int = float or vice-versa). But the float type doesn't exist when -fmbyas is on. That's because that architecture doesn't support floating-point operations

#### Multi-value:
- All such variables are arrays (including strings)

##### Referencing:
- Referencing works exactly the same as it does in C with the square brackets.

### Variable declaration:
- To declare a variable x equal to any singular value (char, bool, int), you do `x := [value]` without the square braces
- To declare a variable y equal to a string, array or a pointer, you do `y := mem [value]` without the square braces. y is now equal to a pointer pointing to the memory location of the value or variable that substitues [value]
- To declare a variable z equal to the value that a variable or value is pointing to you do `z := mem ref [value]`

### Variable assignment:
- To assign a variable x of a singular value (char, bool, int) to another value you do `x = [value]`
- To assign a variable y to the RAM location of x you do `y = mem x`
- To assign a variable z to the value that x is pointing to you do `z = mem ref x`. This dereferences x and sets z equal to its location

### Specific symbols:
- Symbols such as "\*" and "&" have been chosen to be removed from the language in favor of "mem" and "ref" due to attaching symbols to variable names being unintuitive
- Symbols such as """, "'" and "[]" have been kept as they symbolize important distinctions between variable types

## Functions:

- All functions are defined in the same way no matter the intended return type.
 `[function name] [args] {}`
Example:
- main argc argv {}

- Return is written as `ret [value]`. If no return has been triggered, it falls back to returning the constant 0

- Functions that aren't used to get a value can be written without parenthesis
Example:
- `printf "Hello, World!"`

- If a function is called to get a value, parenthesis are necessary to distinguish between different cases that look the same without them
Example:
- `x := f(z) + y`

## Flow-Control
- if, else if (elif) and else work exactly the same way they do in other languages. They just have different names
- `if ([condition]) {}` turns into `[condition] -> {}`
- `else if ([condition]) {}` turns into `[condition] !->`
- `else {}` turns into `!-> {}`
Example:
```owo
x := 2;

x == 0 -> {
    printf "Zero";
} 
x == 1 !-> {
    printf "One";
} 
!-> {
    printf "Other";
}
```

## Loops and Loop Control:
- There's only one type of loop, which is `loop {}`. It's exactly the same as `while (true)`
- To get out of a loop once you're done, you can do `brk;`
Example:
```owo
i := 0;
loop {
    printf "%d" i;
    i++;
    i == 10 -> {brk;}
}
```
*(C equivalent)*
```c
for (int i = 0; i < 10; i++) {
    printf("%d", i);
}
```

## Arithmetic, Comparisons and Logical stuff:
- +, -, \*, /, >>, <<, |, &, !, ||, &&, ==, !=, <=, >=, < and > work the exact same as in C
- ++, --, +=, -=, \*= and /= also work the exact same as in C

## Including / Importing:
- To include a C header file from PATH you can do `imp <header_name.h>`. If you want to include from local path or absolute path you can do `imp "header_name.h"`
- To include an OwOVM library file from PATH you can do `imp <library_name.owol>`. If you want to include by local or absolute path you can do `imp "library_name.owol"`
- To include another OwO script from PATH you can do `imp <script_name.owo>`. If you want to include by local or absolute path you can do `imp "script_name.owo"`

## Comments:
- OwO-Lang only supports single-line comments with double slash `//`
Example:
```owo
//This is a comment
```

## Build-target differences:
- `-compat` and (default) transpile to C first before invoking your system compiler. If you're planning to interface with C libraries, it's best to use -compat to make sure you're not passing 64 bit integers to 32 bit functions
- `-vm` compiles to OwOVM bytecode that can use OwOVM libraries
- `-fmbyas` compiles directly to FMBYAS assembly that can be assembled by the [EzCPU](https://github.com/Ferriit/EzCPU/tree/dev) assembler

### Standard libraries:
- `-compat` and `(default)` rely on the C standard library for heavy lifting
- `-vm` relies on the OwOVM standard library with the same functions as the C standard library
- `-fmbyas` uses the fmbylib standard library. It only includes the `loadreg reg_code value` and `movreg(reg_code, value)` for loading values into registers and moving values from registers to variables and macros for the available registers (r0 - r7, io0 - io7, dbg, pc, stackptr, cmpreg and funcret).

- Every compilation target except `-vm` has access to the keyword `asm opcode arg1 arg2 arg3 [all args necessary]`, which inserts an assembly instruction with that opcode and those arguments

### Limitations:
- `(default)`: Transpiles to 64-bit C code.
- `-compat`: Transpiles to 32-bit C code. Necessary when working with 3rd-party C code, which usually runs on 32-bit or when compiling for older hardware.
- `-vm`: Compiles to OwOVM bytecode which runs on the OwOVM Virtual Machine. Doesn't support the `asm` keyword.
- `-fmbyas`: Compiles to 16-bit FMBYAS assembly. Necessary when compiling for EzCPU or SimpleCPU. Cannot interact with either C code or OwOVM. Doesn't support floating-point numbers out of the box.
