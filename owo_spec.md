# OwO-Lang Specification

OwO-Lang is build on a set of core ideas:
1. **Pattern-finding over keywords:** the language is parsed and compiled primarily through structure and symbol patterns rather than reserved words
2. **Compact expressiveness:** syntax should communicate maximum meaning with minimal visual noise
3. **Non-clutterness:** symbols shouldn't be attached to a keyword or name to signify something else

This can then be expanded to:

1. All types are fundamentally 16, 32 or 64-bit ints, there's no type-checking 
2. It builds on pattern-finding (if (x == 2) {} becomes x == 2 -> {}) 
3. Function calls don't require parenthesis (printf("Hello, World!") becomes printf "Hello, World!". But int x = y + f(z) becomes x := y + f(z) since the parenthesis are needed for clarity) 
4. The language is fully-procedural like C 
5. It compiles to an intermediary language before that gets compiled to assembly and gets assembled and linked or compiled to the OwOVM.
6. Variable definition doesn't need a special keyword since every variable is an int (except for strings and arrays, both of which are pointers). You just use := instead of = 
7. Functions are defined without a keyword (int main(int argc, char** argv) {} becomes main argc argv {})
8. Assigning pointers shouldn't be with "\*x", it should use a keyword such as "mem" instead of "\*". (&x becomes ref x)

## Compile flags
### Target flags:
- (No target flag) - Transpiles to C with 64-bit everything before calling GCC, Clang, MSVC or whichever C-compiler you have installed
- -compat - Transpiles to C with **32-bit** integers instead of 64 bit. This is to improve backwards **compatibility**
- -vm - Compiles to bytecode that can be read by the OwOVM Virtual Machine
- -fmbyas - Compiles to the FMBYAS instruction set. Turns on **16-bit** integers due to architecture limitations. Can be run either with the [EzCPU](https://github.com/ferriit/ezcpu) emulator or the EzCPU in the game Scrap Mechanic. Though that requires manually inputting the machine code generated by the [EzCPU](https://github.com/ferriit/ezcpu) assembler.

### Linking flags:
- -l[library name] - Links whatever library has that library name. Links binaries. Looks in your PATH variable for binaries
- -L[path to library] - Links whatever library binary is at that position
- -ol - Links an OwOVM library file (\*.owol). Looks in your PATH variable
- -oL - Links an OwOVM library file (\*.owol) by its path
- -static - Links statically. Works for both binaries and OwOVM
- -shared - Links dynamically (default). Works for both binaries and OwOVM
*(Note that FMBYAS doesn't support shared/dynamic linking)*


## Keywords:
1. mem - "Memory location of ...". Assigns new memory for a constant and returns a pointer to said constant. If used on a variable (`mem x`), it's the same as `\*x` in C (pointer)
2. ref - "Value at the memory location ...". The same as a dereferencing a pointer (`&x`).


## Variables:

- All variables that can be expressed with a single value are of type int at their core (64-bit on standard, 32-bit if `-compat` is on and 16-bit if `-fmbyas` is on)
- Variables like strings or arrays are expressed as pointers pointing to a memory location

### Variable types:
#### Single-value:
- All such variables are integers except floats.
1. ints behave like normal
1. bools are false if they're exactly equal to 0b0 and true otherwise
1. chars works as in C with each character being mapped to a certain int

- Floats are assigned as "float" and not "int" (meaning you can't do int = float or vice-versa). But the float type doesn't exist when -fmbyas is on. That's because that architecture doesn't support floating-point operations

#### Multi-value:
- All such variables are arrays (including strings)

### Variable declaration:
- To declare a variable x equal to any singular value (char, bool, int), you do `x := [value]` without the square braces
- To declare a variable y equal to a string, array or a pointer, you do `y := mem [value]` without the square braces. y is now equal to a pointer pointing to the memory location of the value or variable that substitues [value]
- To declare a variable z equal to the value that a variable or value is pointing to you do `z := mem ref [value]`

### Variable assignment:
- To assign a variable x of a singular value (char, bool, int) to another value you do `x = [value]`
- To assign a variable y to the RAM location of x you do `y = mem x`
- To assign a variable z to the value that x is pointing to you do `z = mem ref x`. This dereferences x and sets z equal to its location

### Specific symbols:
- Symbols such as "\*" and "&" have been chosen to be removed from the language in favor of "mem" and "ref" due to attaching symbols to variable names being unintuitive
- Symbols such as """, "'" and "[]" have been kept as they symbolize important distinctions between variable types
